/**
 * Helper functions that helps working with EditorControls.* components.
 */

import { useSelect } from '@wordpress/data';
import { useContext } from '@wordpress/element';
import EditorControls from '../_EditorControls';

const operators = [ '==', '!=', '<', '>' ];

/**
 * @return {Object} Returns EditorControls.Context values;
 */
export function getEditorControlsContext() {
	// eslint-disable-next-line react-hooks/rules-of-hooks
	return useContext( EditorControls.Context );
}

/**
 * @return {string} Returns block name from EditorControls.Context.
 */
export function getBlockName() {
	return getEditorControlsContext()?.blockName;
}

/**
 * @return {Object|Array} Returns all block data used while registering it.
 */
export function getBlockData() {
	// eslint-disable-next-line react-hooks/rules-of-hooks
	return useSelect( ( select ) => {
		const blockName = getBlockName();
		return select( 'core/blocks' ).getBlockType( blockName );
	}, [] );
}

/**
 * @param {string} attributeName
 * @return {Function} Returns default "onChange" function for any EditorControls.* sub-component.
 */
export function getDefaultOnChangeFromContext( attributeName ) {
	if ( attributeName !== null && attributeName !== '' ) {
		const setAttributes = getEditorControlsContext()?.setAttributes;

		return ( newValue ) => {
			const setAttributeParam = {};
			setAttributeParam[ attributeName ] = newValue;
			setAttributes( setAttributeParam );
		};
	}
	return () => {};
}

/**
 * @param {string} blockName
 * @return {Object|Array} Returns attributes definitions which are exact same attributes that were used when registering block.
 */
export function getBlockAttributesDefinitions( blockName ) {
	// eslint-disable-next-line react-hooks/rules-of-hooks
	return useSelect( ( select ) => {
		return select( 'core/blocks' ).getBlockType( blockName ).attributes;
	}, [] );
}

/**
 * @param {string} blockName
 * @param {string} attributeName
 * @param {string} subFieldName
 * @return {Object} Returns attributes definitions which are exact same attributes that were used when registering block.
 */
export function getBlockAttributeSubfieldDefinition( blockName, attributeName, subFieldName ) {
	try {
		const blockAttributesDefinitions = getBlockAttributesDefinitions( blockName );
		if ( typeof blockAttributesDefinitions === 'object' ) {
			// eslint-disable-next-line no-unsafe-optional-chaining
			for ( const subField of blockAttributesDefinitions[ attributeName ]?.sub_fields ) {
				if ( subField.name === subFieldName ) {
					return subField;
				}
			}
		}
	} catch ( error ) {
		/* do nothing */
	}

	return {};
}

/**
 * @param {string} attributeName
 * @param {string|null} parent
 * @return {Object} Returns attribute using EditorControls.Context.
 */
export function getAttributeFromBlockStore( attributeName, parent = null ) {
	const blockData = getBlockData();
	const { attributes = {} } = blockData;

	if ( attributes ) {
		if ( parent ) {
			const parentAttributeName = getAttributeNameFromBlockStoreByKey( parent );
			if ( parentAttributeName && typeof attributes[ parentAttributeName ] !== 'undefined' ) {
				const { sub_fields: subFields = [] } = attributes[ parentAttributeName ];

				return subFields.filter( ( field ) => {
					return field.name === attributeName;
				} )[ 0 ];
			}
		} else if ( typeof attributes[ attributeName ] !== 'undefined' ) {
			return attributes[ attributeName ];
		}
	}
	return {};
}

/**
 * @param {string} attributeName
 * @param {*} defaultValue
 * @return {*} Returns attribute's value using EditorControls.Context.
 */
export function getAttributeValueFromContext( attributeName, defaultValue = null ) {
	const attributes = getEditorControlsContext()?.attributes;
	if ( attributes && typeof attributes[ attributeName ] !== 'undefined' ) {
		return attributes[ attributeName ];
	}

	return defaultValue;
}

/**
 * @param {string} attributeKey
 * @return {*} Returns attribute found by "key" prop - this one is auto-generated by ACF plugin.
 */
export function getAttributeNameFromBlockStoreByKey( attributeKey ) {
	const blockData = getBlockData();

	let foundAttributeName = null;
	Object.keys( blockData.attributes ).forEach( ( attributeName ) => {
		const { key } = blockData.attributes[ attributeName ];
		if ( key && key === attributeKey ) {
			foundAttributeName = attributeName;
		}
	} );

	return foundAttributeName;
}

/**
 * @param {Object} attributes
 * @return {string} Returns WordPress useBlockProps result extended by FreshBook's classes.
 */
export function getCommonBlockSettingsClass( attributes ) {
	const classesToPass = [];

	if ( attributes?.style_overrides ) {
		attributes.style_overrides.forEach( ( styleOverride ) => {
			classesToPass.push(
				`${ styleOverride.property }${
					styleOverride.direction
				}${ styleOverride?.breakpoint?.replace( 'null', '' ) }-${ styleOverride.amount }`
			);
		} );
	}

	if ( attributes?.block_settings_tracking_section ) {
		classesToPass.push( `trackingSection-${ attributes.block_settings_tracking_section }` );
	}

	if ( attributes?.block_settings_wide_block ) {
		classesToPass.push( 'wide-block' );
	}

	if ( attributes?.block_settings_narrow_content_within_wide_block ) {
		classesToPass.push( 'wide-block--padded' );
	}

	return classesToPass.join( ' ' );
}

/**
 * @param {string} fieldNameToCheck
 * @param {Object} props
 * @return {boolean} Return if ACF Conditional Logic is validated to field.
 */
export function isConditionalLogicValidated( fieldNameToCheck, props = {} ) {
	let validated = false;

	if ( fieldNameToCheck !== null && fieldNameToCheck !== '' ) {
		const attributeToCheck = getAttributeFromBlockStore( fieldNameToCheck );
		const { conditional_logic: conditionalLogic = attributeToCheck?.conditional_logic } = props;

		if ( Array.isArray( conditionalLogic ) && conditionalLogic.length > 0 ) {
			conditionalLogic.forEach( ( conditionalLogicGroup ) => {
				const validatedConditionalLogicGroup = conditionalLogicGroup.filter(
					( conditionalLogicToCheck ) => {
						let valueToCheck = getAttributeValueFromContext(
							getAttributeNameFromBlockStoreByKey( conditionalLogicToCheck.field )
						);

						let conditionalLogicToCheckValue = conditionalLogicToCheck.value;
						if (
							operators.indexOf( conditionalLogicToCheck.operator ) >= 0 &&
							typeof valueToCheck !== 'boolean'
						) {
							conditionalLogicToCheckValue = `'${ conditionalLogicToCheckValue }'`;
							valueToCheck = `'${ valueToCheck }'`;
						}

						// eslint-disable-next-line no-eval
						return eval(
							`${ valueToCheck } ${ conditionalLogicToCheck.operator } ${ conditionalLogicToCheckValue }`
						);
					}
				);

				if ( validatedConditionalLogicGroup.length === conditionalLogicGroup.length ) {
					validated = true;
				}
			} );
		} else {
			validated = true;
		}
	} else {
		validated = true;
	}

	return validated;
}

/**
 * @param {string} type
 * @return {JSX.Element|null} Returns proper EditorControls.* component by passes "type".
 */
export function getEditorControlsComponentByType( type ) {
	switch ( type ) {
		case 'accordion':
			return EditorControls.Acf.Accordion;
		case 'checkbox':
			return EditorControls.Checkbox;
		case 'color_picker':
			return EditorControls.ColourPicker;
		case 'file':
			return EditorControls.File;
		case 'gallery':
			return EditorControls.Gallery;
		case 'group':
			return EditorControls.Acf.Group;
		case 'image':
			return EditorControls.Image;
		case 'link':
			return EditorControls.Link;
		case 'number':
			return EditorControls.Number;
		case 'range':
			return EditorControls.Range;
		case 'repeater':
			return EditorControls.Acf.Repeater;
		case 'select':
			return EditorControls.Select;
		case 'text':
			return EditorControls.Text;
		case 'textarea':
			return EditorControls.TextArea;
		case 'true_false':
			return EditorControls.TrueFalse;
		case 'url':
			return EditorControls.Text;
		case 'wysiwyg':
			return EditorControls.TextArea;
		default:
			return null;
	}
}
